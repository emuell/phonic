use core::time;
use std::{
    any::Any,
    sync::{
        atomic::{self, AtomicBool},
        Arc,
    },
    thread,
    time::Duration,
};

use basedrop::{Collector, Handle, Owned};
use crossbeam_channel::Sender;
use crossbeam_queue::ArrayQueue;
use dashmap::DashMap;
use four_cc::FourCC;

use crate::{
    effect::{Effect, EffectMessage, EffectMessagePayload},
    error::Error,
    output::OutputDevice,
    parameter::ParameterValueUpdate,
    source::{
        amplified::{AmplifiedSource, AmplifiedSourceMessage},
        converted::ConvertedSource,
        file::{FilePlaybackMessage, FileSource},
        mixed::{MixedSource, MixerMessage},
        panned::{PannedSource, PannedSourceMessage},
        resampled::ResamplingQuality,
        synth::{SynthPlaybackMessage, SynthSource},
        unique_source_id,
    },
};

// -------------------------------------------------------------------------------------------------

/// Unique ID for played back file or synth sources.
pub type PlaybackId = usize;

/// Unique ID for newly added mixers.
pub type MixerId = usize;

/// Unique ID for newly added effects.
pub type EffectId = usize;

// -------------------------------------------------------------------------------------------------

/// Custom context type for playback status events.
pub type PlaybackStatusContext = Arc<dyn Any + Send + Sync>;

/// Events send back from File or Synth sources via the player to the user.
pub enum PlaybackStatusEvent {
    Position {
        /// Unique id to resolve played back sources.
        id: PlaybackId,
        /// The file path for file based sources, else a name to somewhat identify the source.
        path: Arc<String>,
        /// Custom, optional context, passed along when starting playback.
        context: Option<PlaybackStatusContext>,
        /// Source's actual playback position in wallclock-time.
        position: Duration,
    },
    Stopped {
        /// Unique id to resolve played back sources
        id: PlaybackId,
        /// the file path for file based sources, else a name to somewhat identify the source
        path: Arc<String>,
        /// Custom, optional context, passed along when starting playback.
        context: Option<PlaybackStatusContext>,
        /// true when the source finished playing (e.g. reaching EOF), false when manually stopped
        exhausted: bool,
    },
}

// -------------------------------------------------------------------------------------------------

/// How to move an effect within a mixer.
pub enum EffectMovement {
    /// Negative value shift the effect towards the start, positive ones towards the end.
    Direction(i32),
    /// Move effect to the start of the effect chain.
    Start,
    /// Move effect to the end of the effect chain.
    End,
}

// -------------------------------------------------------------------------------------------------

/// Wraps File and Synth Playback messages together into one object, allowing to easily stop them.
#[derive(Clone)]
pub(crate) enum PlaybackMessageQueue {
    File(Arc<ArrayQueue<FilePlaybackMessage>>),
    Synth(Arc<ArrayQueue<SynthPlaybackMessage>>),
}

impl PlaybackMessageQueue {
    pub fn send_stop(&self) -> Result<(), Error> {
        match self {
            PlaybackMessageQueue::File(sender) => sender
                .push(FilePlaybackMessage::Stop)
                .map_err(|_msg| Error::SendError),
            PlaybackMessageQueue::Synth(sender) => sender
                .push(SynthPlaybackMessage::Stop)
                .map_err(|_msg| Error::SendError),
        }
    }
}

// -------------------------------------------------------------------------------------------------

/// Player internal info about a currently playing source.
#[derive(Clone)]
pub(crate) struct PlayingSource {
    mixer_id: MixerId,
    playback_message_queue: PlaybackMessageQueue,
    volume_message_queue: Arc<ArrayQueue<AmplifiedSourceMessage>>,
    panning_message_queue: Arc<ArrayQueue<PannedSourceMessage>>,
}

// -------------------------------------------------------------------------------------------------

/// Playback controller, which continuously fills an [`OutputDevice`]s stream with audio data
/// generated by one or more [`Source`](crate::Source)s.
///
/// It can play an unlimited number of [`FileSource`] or [`SynthSource`] sources and allows
/// monitoring playback position via an optional [`PlaybackStatusEvent`] [`Sender`].
///
/// New sources can be added any time, and can be stopped and seeked (seeking works for file
/// based sources only).
///
/// The player also supports creating complex DSP graphs by adding sub-mixers and [`Effect`]s.
/// Initially, a `Player` contains a single main mixer only. You can add effects to this mixer
/// using [`add_effect`](Self::add_effect). Audio sources played without specifying a target mixer
/// will be routed through the main mixer and its effects.
///
/// To create more advanced routing, you can add new mixers as sub-mixers to existing ones
/// using [`add_mixer`](Self::add_mixer). Each mixer can have its own chain of effects. When
/// playing a source, you can specify a `target_mixer` in the playback options to direct its output
/// to a specific sub-mixer. This allows for parallel processing paths, such as applying different
/// effects to different groups of sounds.
///
/// NB: For playback of [`SynthSource`]s, the `dasp-synth` feature needs to be enabled.
pub struct Player {
    output_device: Box<dyn OutputDevice>,
    playing_sources: Arc<DashMap<PlaybackId, PlayingSource>>,
    playback_status_sender: Sender<PlaybackStatusEvent>,
    collector_handle: Handle,
    collector_running: Arc<AtomicBool>,
    mixer_event_queues: Arc<DashMap<MixerId, Arc<ArrayQueue<MixerMessage>>>>,
    mixer_effects: Arc<DashMap<EffectId, (MixerId, Option<&'static str>)>>,
}

impl Player {
    /// The ID of the main mixer, which is always present.
    const MAIN_MIXER_ID: MixerId = 0;

    /// Create a new Player for the given [`OutputDevice`].
    /// Param `playback_status_sender` is an optional channel which can be used to receive
    /// playback status events for the currently playing sources.
    pub fn new<S: Into<Option<Sender<PlaybackStatusEvent>>>>(
        output_device: impl OutputDevice + 'static,
        playback_status_sender: S,
    ) -> Self {
        // Memorize the sink
        let mut output_device = Box::new(output_device);

        // Create a proxy for the playback status channel, so we can trap stop messages
        let playing_sources = Arc::new(DashMap::with_capacity(1024));
        let playback_status_sender =
            Self::handle_playback_events(playback_status_sender.into(), playing_sources.clone());

        // Create audio garbage collector and thread
        let collector = Collector::new();
        let collector_handle = collector.handle();
        let collector_running = Arc::new(AtomicBool::new(true));
        Self::handle_drop_collects(collector, collector_running.clone());

        // Create a mixer source and add it to the audio sink
        let mixer_source =
            MixedSource::new(output_device.channel_count(), output_device.sample_rate());
        let mixer_event_queue = mixer_source.message_queue();
        let mixer_event_queues = Arc::new(DashMap::new());
        mixer_event_queues.insert(Self::MAIN_MIXER_ID, mixer_event_queue);

        let mixer_effects = Arc::new(DashMap::new());

        // assign our main mixer source to the sink
        output_device.play(Box::new(mixer_source));

        Self {
            output_device,
            playing_sources,
            playback_status_sender,
            collector_handle,
            collector_running,
            mixer_event_queues,
            mixer_effects,
        }
    }

    /// Our audio device's suspended state.
    pub fn output_suspended(&self) -> bool {
        self.output_device.is_suspended()
    }

    /// Our audio device's actual sample rate.
    pub fn output_sample_rate(&self) -> u32 {
        self.output_device.sample_rate()
    }
    /// Our audio device's actual sample channel count.
    pub fn output_channel_count(&self) -> usize {
        self.output_device.channel_count()
    }
    /// Our actual playhead pos in samples (NOT sample frames)
    pub fn output_sample_position(&self) -> u64 {
        self.output_device.sample_position()
    }
    /// Our actual playhead pos in sample frames
    pub fn output_sample_frame_position(&self) -> u64 {
        self.output_sample_position() / self.output_channel_count() as u64
    }

    /// Our output's global volume factor
    pub fn output_volume(&self) -> f32 {
        self.output_device.volume()
    }
    /// Set a new global volume factor
    pub fn set_output_volume(&mut self, volume: f32) {
        assert!(volume >= 0.0);
        self.output_device.set_volume(volume);
    }

    /// Get a copy of our playback status sender channel.
    /// Should be used by custom audio sources only.
    pub fn playback_status_sender(&self) -> Sender<PlaybackStatusEvent> {
        self.playback_status_sender.clone()
    }

    /// Start audio playback.
    pub fn is_running(&self) -> bool {
        self.output_device.is_running()
    }

    /// Start audio playback.
    pub fn start(&mut self) {
        self.output_device.resume();
    }

    /// Stop audio playback. This will only pause and thus not drop any playing sources. Use the
    /// `start` function to start it again. Use function `stop_all_sources` to drop all sources.
    pub fn stop(&mut self) {
        self.output_device.pause();
    }

    /// Play a self created or cloned file source.
    pub fn play_file_source<F: FileSource, T: Into<Option<u64>>>(
        &mut self,
        file_source: F,
        start_time: T,
    ) -> Result<PlaybackId, Error> {
        self.play_file_source_with_context(file_source, start_time, None)
    }
    /// Play a self created or cloned file source with the given playback status context.
    pub fn play_file_source_with_context<F: FileSource, T: Into<Option<u64>>>(
        &mut self,
        file_source: F,
        start_time: T,
        context: Option<PlaybackStatusContext>,
    ) -> Result<PlaybackId, Error> {
        let mixer_id = file_source
            .playback_options()
            .target_mixer
            .unwrap_or(Self::MAIN_MIXER_ID);
        let mixer_event_queue = self
            .mixer_event_queues
            .get(&mixer_id)
            .ok_or(Error::MixerNotFoundError(mixer_id))?
            .clone();
        // make sure the source has a valid playback status channel
        let mut file_source = file_source;
        if file_source.playback_status_sender().is_none() {
            file_source.set_playback_status_sender(Some(self.playback_status_sender.clone()));
        }
        // set playback context
        file_source.set_playback_status_context(context);
        // memorize source in playing sources map
        let playback_id = file_source.playback_id();
        let playback_volume = file_source.playback_options().volume;
        let playback_panning = file_source.playback_options().panning;
        let playback_message_queue =
            PlaybackMessageQueue::File(file_source.playback_message_queue());
        // convert file to mixer's rate and channel layout
        let converted_source = ConvertedSource::new(
            file_source,
            self.output_device.channel_count(),
            self.output_device.sample_rate(),
            ResamplingQuality::Default,
        );
        // apply volume options
        let amplified_source = AmplifiedSource::new(converted_source, playback_volume);
        let volume_message_queue = amplified_source.message_queue();
        // apply panning options
        let panned_source = PannedSource::new(amplified_source, playback_panning);
        let panning_message_queue = panned_source.message_queue();
        self.playing_sources.insert(
            playback_id,
            PlayingSource {
                playback_message_queue: playback_message_queue.clone(),
                mixer_id,
                volume_message_queue: volume_message_queue.clone(),
                panning_message_queue: panning_message_queue.clone(),
            },
        );
        // send the source to the mixer
        if mixer_event_queue
            .push(MixerMessage::AddSource {
                playback_id,
                playback_message_queue,
                volume_message_queue,
                panning_message_queue,
                source: Owned::new(&self.collector_handle, Box::new(panned_source)),
                sample_time: start_time.into().unwrap_or(0),
            })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to play a file source.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }
        // return new file's id
        Ok(playback_id)
    }

    /// Play a self created synth source with the given playback options.
    pub fn play_synth_source<S: SynthSource, T: Into<Option<u64>>>(
        &mut self,
        synth_source: S,
        start_time: T,
    ) -> Result<PlaybackId, Error> {
        self.play_synth_source_with_context(synth_source, start_time, None)
    }
    /// Play a self created synth source with the given playback options and
    /// playback status context.
    pub fn play_synth_source_with_context<S: SynthSource, T: Into<Option<u64>>>(
        &mut self,
        synth_source: S,
        start_time: T,
        context: Option<PlaybackStatusContext>,
    ) -> Result<PlaybackId, Error> {
        let mixer_id = synth_source
            .playback_options()
            .target_mixer
            .unwrap_or(Self::MAIN_MIXER_ID);
        let mixer_event_queue = self
            .mixer_event_queues
            .get(&mixer_id)
            .ok_or(Error::MixerNotFoundError(mixer_id))?
            .clone();
        // make sure the source has a valid playback status channel
        let mut synth_source = synth_source;
        if synth_source.playback_status_sender().is_none() {
            synth_source.set_playback_status_sender(Some(self.playback_status_sender.clone()));
        }
        synth_source.set_playback_status_context(context);
        // memorize source in playing sources map
        let playback_id = synth_source.playback_id();
        let playback_volume = synth_source.playback_options().volume;
        let playback_panning = synth_source.playback_options().panning;
        let playback_message_queue =
            PlaybackMessageQueue::Synth(synth_source.playback_message_queue());
        // convert file to mixer's rate and channel layout
        let converted_source = ConvertedSource::new(
            synth_source,
            self.output_device.channel_count(),
            self.output_device.sample_rate(),
            ResamplingQuality::Default, // usually unused
        );
        // apply volume options
        let amplified_source = AmplifiedSource::new(converted_source, playback_volume);
        let volume_message_queue = amplified_source.message_queue();
        // apply panning options
        let panned_source = PannedSource::new(amplified_source, playback_panning);
        let panning_message_queue = panned_source.message_queue();
        self.playing_sources.insert(
            playback_id,
            PlayingSource {
                playback_message_queue: playback_message_queue.clone(),
                mixer_id,
                volume_message_queue: volume_message_queue.clone(),
                panning_message_queue: panning_message_queue.clone(),
            },
        );
        // send the source to the mixer
        if mixer_event_queue
            .push(MixerMessage::AddSource {
                playback_id,
                playback_message_queue,
                volume_message_queue,
                panning_message_queue,
                source: Owned::new(&self.collector_handle, Box::new(panned_source)),
                sample_time: start_time.into().unwrap_or(0),
            })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to play a synth source.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }
        // return new synth's id
        Ok(playback_id)
    }

    /// Add a new mixer to an existing mixer.
    /// Use None as mixer id to add it to the main mixer.
    pub fn add_mixer<M: Into<Option<MixerId>>>(
        &mut self,
        parent_mixer_id: M,
    ) -> Result<MixerId, Error> {
        let parent_mixer_id = parent_mixer_id.into().unwrap_or(Self::MAIN_MIXER_ID);
        let parent_mixer_event_queue = self
            .mixer_event_queues
            .get(&parent_mixer_id)
            .ok_or(Error::MixerNotFoundError(parent_mixer_id))?
            .clone();

        let new_mixer = Box::new(MixedSource::new(
            self.output_channel_count(),
            self.output_sample_rate(),
        ));
        let new_mixer_queue = new_mixer.message_queue();
        let new_mixer_id = unique_source_id();

        // Send message to parent mixer
        if parent_mixer_event_queue
            .push(MixerMessage::AddMixer {
                id: new_mixer_id,
                mixer: new_mixer,
            })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to add a new mixer.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }

        self.mixer_event_queues
            .insert(new_mixer_id, new_mixer_queue);
        self.mixer_effects
            .insert(new_mixer_id, (parent_mixer_id, None));

        Ok(new_mixer_id)
    }

    /// Remove a mixer and all its effects from the parent mixer.
    pub fn remove_mixer(&mut self, mixer_id: MixerId) -> Result<(), Error> {
        // Can't remove the main mixer
        if mixer_id == Self::MAIN_MIXER_ID {
            return Err(Error::ParameterError(
                "Cannot remove the main mixer".to_string(),
            ));
        }

        // Find the parent mixer
        let parent_mixer_id = self
            .mixer_effects
            .get(&mixer_id)
            .map(|entry| entry.value().0)
            .ok_or(Error::MixerNotFoundError(mixer_id))?;

        let parent_mixer_event_queue = self
            .mixer_event_queues
            .get(&parent_mixer_id)
            .ok_or(Error::MixerNotFoundError(parent_mixer_id))?
            .clone();

        // Send the remove message to parent
        if parent_mixer_event_queue
            .push(MixerMessage::RemoveMixer { id: mixer_id })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to remove a mixer.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }

        // Remove all effects that belong to this mixer
        let effects_to_remove: Vec<EffectId> = self
            .mixer_effects
            .iter()
            .filter_map(|entry| {
                let (effect_id, (owner_mixer_id, _)) = (entry.key(), entry.value());
                if *owner_mixer_id == mixer_id {
                    Some(*effect_id)
                } else {
                    None
                }
            })
            .collect();

        for effect_id in effects_to_remove {
            self.mixer_effects.remove(&effect_id);
        }

        // Remove the mixer from tracking maps
        self.mixer_event_queues.remove(&mixer_id);
        self.mixer_effects.remove(&mixer_id);

        Ok(())
    }

    /// Remove all sub-mixers from the given mixer.
    /// Use None as mixer_id to remove all sub-mixers from the main mixer.
    pub fn remove_all_mixers<M: Into<Option<MixerId>>>(
        &mut self,
        mixer_id: M,
    ) -> Result<(), Error> {
        let mixer_id = mixer_id.into().unwrap_or(Self::MAIN_MIXER_ID);

        // Find all sub-mixers that have this mixer as their parent
        let sub_mixers_to_remove: Vec<MixerId> = self
            .mixer_effects
            .iter()
            .filter_map(|entry| {
                let (sub_mixer_id, (parent_mixer_id, effect_name)) = (entry.key(), entry.value());
                // A mixer entry has None as effect_name
                if *parent_mixer_id == mixer_id && effect_name.is_none() {
                    Some(*sub_mixer_id)
                } else {
                    None
                }
            })
            .collect();

        // Remove each sub-mixer
        for sub_mixer_id in sub_mixers_to_remove {
            self.remove_mixer(sub_mixer_id)?;
        }

        Ok(())
    }

    /// Add an effect to the given mixer's output.
    /// Use None as mixer_id to add the effect to the main mixer.
    pub fn add_effect<E: Effect, M: Into<Option<MixerId>>>(
        &mut self,
        effect: E,
        mixer_id: M,
    ) -> Result<EffectId, Error> {
        let mixer_id = mixer_id.into().unwrap_or(Self::MAIN_MIXER_ID);
        let mixer_event_queue = self
            .mixer_event_queues
            .get(&mixer_id)
            .ok_or(Error::MixerNotFoundError(mixer_id))?
            .clone();

        let channel_count = self.output_channel_count();
        // The effect's parent mixer uses a temp buffer of size:
        let max_frames = MixedSource::MAX_MIX_BUFFER_SAMPLES / channel_count;

        let effect_name = effect.name();
        let mut effect = Box::new(effect);
        effect.initialize(self.output_sample_rate(), channel_count, max_frames)?;

        let id = unique_source_id();
        if mixer_event_queue
            .push(MixerMessage::AddEffect { id, effect })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to add a new effect.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }

        self.mixer_effects.insert(id, (mixer_id, Some(effect_name)));

        Ok(id)
    }

    /// Move an effect within the given mixer's effect list to reorder the processing chain.
    pub fn move_effect<M: Into<Option<MixerId>>>(
        &mut self,
        movement: EffectMovement,
        effect_id: EffectId,
        mixer_id: M,
    ) -> Result<(), Error> {
        let mixer_id = mixer_id.into().unwrap_or(Self::MAIN_MIXER_ID);

        // Verify the effect exists and belongs to the specified mixer
        let (effect_mixer_id, _) = *self
            .mixer_effects
            .get(&effect_id)
            .ok_or(Error::EffectNotFoundError(effect_id))?
            .value();

        if effect_mixer_id != mixer_id {
            return Err(Error::ParameterError(format!(
                "Effect {} does not belong to mixer {}",
                effect_id, mixer_id
            )));
        }

        let mixer_event_queue = self
            .mixer_event_queues
            .get(&mixer_id)
            .ok_or(Error::MixerNotFoundError(mixer_id))?
            .clone();

        // Send the move message to the mixer
        if mixer_event_queue
            .push(MixerMessage::MoveEffect {
                id: effect_id,
                movement,
            })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to move effect.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }

        Ok(())
    }

    /// Remove an effect from the given mixer.
    pub fn remove_effect(&mut self, effect_id: EffectId) -> Result<(), Error> {
        // Send the remove message
        if self
            .effect_mixer_event_queue(effect_id)?
            .push(MixerMessage::RemoveEffect { id: effect_id })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to remove a effect.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }

        // Remove from tracking map
        self.mixer_effects.remove(&effect_id);
        Ok(())
    }

    /// Remove all effects from the given mixer.
    /// Use None as mixer_id to remove all effects from the main mixer.
    pub fn remove_all_effects<M: Into<Option<MixerId>>>(
        &mut self,
        mixer_id: M,
    ) -> Result<(), Error> {
        let mixer_id = mixer_id.into().unwrap_or(Self::MAIN_MIXER_ID);

        // Find all effects belonging to this mixer
        let effects_to_remove = self
            .mixer_effects
            .iter()
            .filter_map(|entry| {
                let (effect_id, (owner_mixer_id, _)) = (entry.key(), entry.value());
                if *owner_mixer_id == mixer_id {
                    Some(*effect_id)
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        // Remove each effect
        for effect_id in effects_to_remove {
            self.remove_effect(effect_id)?;
        }

        Ok(())
    }

    /// Set a raw parameter value on an effect at a specific sample time or immediately.
    ///
    /// The `value` must be of the correct type for the parameter (`f32`, `i32`, `bool`, or the
    /// specific enum type).
    pub fn set_effect_parameter<V: Any + Send + Sync, T: Into<Option<u64>>>(
        &mut self,
        effect_id: EffectId,
        parameter_id: FourCC,
        value: V,
        sample_time: T,
    ) -> Result<(), Error> {
        let sample_time = sample_time.into().unwrap_or(0);
        let value = Owned::new(
            &self.collector_handle,
            ParameterValueUpdate::Raw(Box::new(value)),
        );

        if self
            .effect_mixer_event_queue(effect_id)?
            .push(MixerMessage::ProcessEffectParameterUpdate {
                effect_id,
                parameter_id,
                value,
                sample_time,
            })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Parameter update got skipped!");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            Err(Error::SendError)
        } else {
            Ok(())
        }
    }

    /// Set a normalized parameter value on an effect at a specific sample time or immediately.
    ///
    /// The `value` must be in the range `0.0..=1.0`.
    pub fn set_effect_parameter_normalized<T: Into<Option<u64>>>(
        &mut self,
        effect_id: EffectId,
        parameter_id: FourCC,
        value: f32,
        sample_time: T,
    ) -> Result<(), Error> {
        let sample_time = sample_time.into().unwrap_or(0);
        let value = Owned::new(
            &self.collector_handle,
            ParameterValueUpdate::Normalized(value),
        );

        if self
            .effect_mixer_event_queue(effect_id)?
            .push(MixerMessage::ProcessEffectParameterUpdate {
                effect_id,
                parameter_id,
                value,
                sample_time,
            })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Parameter update got skipped!");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            Err(Error::SendError)
        } else {
            Ok(())
        }
    }

    /// Send a message to an effect at a specific sample time or immediately.
    pub fn send_effect_message<M: EffectMessage + 'static, T: Into<Option<u64>>>(
        &mut self,
        effect_id: EffectId,
        message: M,
        sample_time: T,
    ) -> Result<(), Error> {
        let message = Owned::new(
            &self.collector_handle,
            Box::new(message) as Box<EffectMessagePayload>,
        );
        let sample_time = sample_time.into().unwrap_or(0);

        // check if effect name matches
        let (_, effect_name) = *self
            .mixer_effects
            .get(&effect_id)
            .ok_or(Error::EffectNotFoundError(effect_id))?
            .value();
        if let Some(effect_name) = effect_name {
            if effect_name != message.effect_name() {
                return Err(Error::ParameterError(format!(
                    "Invalid message: Trying to send a `{}` message to effect '{}' (id: {})",
                    message.effect_name(),
                    effect_name,
                    effect_id
                )));
            }
        }

        if self
            .effect_mixer_event_queue(effect_id)?
            .push(MixerMessage::ProcessEffectMessage {
                effect_id,
                message,
                sample_time,
            })
            .is_err()
        {
            log::warn!("Mixer's event queue is full. Failed to send an effect message.");
            log::warn!("Increase the mixer event queue to prevent this from happening...");
            return Err(Error::SendError);
        }

        Ok(())
    }

    /// Change playback position of the given source at a specific sample time or immediately.
    /// This is only supported for files and thus won't do anything for synths.
    pub fn seek_source<T: Into<Option<u64>>>(
        &mut self,
        playback_id: PlaybackId,
        position: Duration,
        sample_time: T,
    ) -> Result<(), Error> {
        if let Some(entry) = self.playing_sources.get(&playback_id) {
            let playing_source = entry.value();
            if let Some(sample_time) = sample_time.into() {
                // pass stop request to mixer (force push stop events!)
                let mixer_queue = self
                    .mixer_event_queues
                    .get(&playing_source.mixer_id)
                    .ok_or(Error::MixerNotFoundError(playing_source.mixer_id))?
                    .clone();
                if mixer_queue
                    .push(MixerMessage::SeekSource {
                        playback_id,
                        position,
                        sample_time,
                    })
                    .is_err()
                {
                    log::warn!("Mixer's event queue is full. Failed to send a seek event.");
                    log::warn!("Increase the mixer event queue to prevent this from happening...");
                    return Err(Error::SendError);
                }

                Ok(())
            } else {
                match &playing_source.playback_message_queue {
                    PlaybackMessageQueue::File(queue) => {
                        if queue.push(FilePlaybackMessage::Seek(position)).is_err() {
                            log::warn!(
                                "File playback's event queue is full. Failed to send seek command."
                            );
                            return Err(Error::SendError);
                        }
                        Ok(())
                    }
                    _ => {
                        log::warn!("Trying to seek a synth source, which is not supported.");
                        Err(Error::MediaFileNotFound)
                    }
                }
            }
        } else {
            Err(Error::MediaFileNotFound)
        }
    }

    /// Set a playing file source's speed at a given sample time in future or immediately,
    /// with the given optional glide rate in semitones per second.
    /// This is only supported for files and thus won't do anything for synths.
    pub fn set_source_speed<T: Into<Option<u64>>>(
        &mut self,
        playback_id: PlaybackId,
        speed: f64,
        glide: Option<f32>,
        sample_time: T,
    ) -> Result<(), Error> {
        // check if the given playback id is still know (playing)
        if let Some(entry) = self.playing_sources.get(&playback_id) {
            let playing_source = entry.value();
            if let Some(sample_time) = sample_time.into() {
                // schedule with the mixer
                let mixer_queue = self
                    .mixer_event_queues
                    .get(&playing_source.mixer_id)
                    .ok_or(Error::MixerNotFoundError(playing_source.mixer_id))?
                    .clone();
                if mixer_queue
                    .push(MixerMessage::SetSourceSpeed {
                        playback_id,
                        speed,
                        glide,
                        sample_time,
                    })
                    .is_err()
                {
                    log::warn!("Mixer's event queue is full. Failed to send a set_speed event.");
                    log::warn!("Increase the mixer event queue to prevent this from happening...");
                    return Err(Error::SendError);
                }
            } else {
                // apply immediately
                match &playing_source.playback_message_queue {
                    PlaybackMessageQueue::File(queue) => {
                        if queue
                            .push(FilePlaybackMessage::SetSpeed(speed, glide))
                            .is_err()
                        {
                            log::warn!(
                                "File playback's event queue is full. Speed event got skipped."
                            );
                            return Err(Error::SendError);
                        }
                    }
                    _ => {
                        log::warn!(
                            "Trying to change speed of a synth source, which is not supported."
                        );
                        return Err(Error::MediaFileNotFound);
                    }
                }
            }
            Ok(())
        } else {
            Err(Error::MediaFileNotFound)
        }
    }

    /// Set a playing source's volume at a given sample time in future or immediately.
    pub fn set_source_volume<T: Into<Option<u64>>>(
        &mut self,
        playback_id: PlaybackId,
        volume: f32,
        sample_time: T,
    ) -> Result<(), Error> {
        // check if the given playback id is still know (playing)
        if let Some(entry) = self.playing_sources.get(&playback_id) {
            let playing_source = entry.value();
            if let Some(sample_time) = sample_time.into() {
                // schedule with the mixer
                let mixer_queue = self
                    .mixer_event_queues
                    .get(&playing_source.mixer_id)
                    .ok_or(Error::MixerNotFoundError(playing_source.mixer_id))?
                    .clone();
                if mixer_queue
                    .push(MixerMessage::SetSourceVolume {
                        playback_id,
                        volume,
                        sample_time,
                    })
                    .is_err()
                {
                    log::warn!("Mixer's event queue is full. Failed to send a set_speed event.");
                    log::warn!("Increase the mixer event queue to prevent this from happening...");
                    return Err(Error::SendError);
                }
            } else {
                // apply immediately
                if playing_source
                    .volume_message_queue
                    .push(AmplifiedSourceMessage::SetVolume(volume))
                    .is_err()
                {
                    log::warn!("File playback's event queue is full. Volume event got skipped.");
                    return Err(Error::SendError);
                }
            }
            Ok(())
        } else {
            Err(Error::MediaFileNotFound)
        }
    }

    /// Set a playing source's panning at a given sample time in future or immediately.
    pub fn set_source_panning<T: Into<Option<u64>>>(
        &mut self,
        playback_id: PlaybackId,
        panning: f32,
        sample_time: T,
    ) -> Result<(), Error> {
        // check if the given playback id is still know (playing)
        if let Some(entry) = self.playing_sources.get(&playback_id) {
            let playing_source = entry.value();
            if let Some(sample_time) = sample_time.into() {
                // schedule with the mixer
                let mixer_queue = self
                    .mixer_event_queues
                    .get(&playing_source.mixer_id)
                    .ok_or(Error::MixerNotFoundError(playing_source.mixer_id))?
                    .clone();
                if mixer_queue
                    .push(MixerMessage::SetSourcePanning {
                        playback_id,
                        panning,
                        sample_time,
                    })
                    .is_err()
                {
                    log::warn!("Mixer's event queue is full. Failed to send a set_speed event.");
                    log::warn!("Increase the mixer event queue to prevent this from happening...");
                    return Err(Error::SendError);
                }
            } else {
                // apply immediately
                if playing_source
                    .panning_message_queue
                    .push(PannedSourceMessage::SetPanning(panning))
                    .is_err()
                {
                    log::warn!("File playback's event queue is full. Panning event got skipped.");
                    return Err(Error::SendError);
                }
            }
            Ok(())
        } else {
            Err(Error::MediaFileNotFound)
        }
    }

    /// Stop a playing file or synth source at a given sample time in future or immediately.
    pub fn stop_source<T: Into<Option<u64>>>(
        &mut self,
        playback_id: PlaybackId,
        stop_time: T,
    ) -> Result<(), Error> {
        // check if the given playback id is still know (playing)
        let remove_from_playing_sources;
        match self.playing_sources.get(&playback_id) {
            Some(entry) => {
                let playing_source = entry.value();
                if let Some(sample_time) = stop_time.into() {
                    // pass event to mixer to schedule it
                    let mixer_queue = self
                        .mixer_event_queues
                        .get(&playing_source.mixer_id)
                        .ok_or(Error::MixerNotFoundError(playing_source.mixer_id))?
                        .clone();
                    // force push stop events!
                    if mixer_queue
                        .force_push(MixerMessage::StopSource {
                            playback_id,
                            sample_time,
                        })
                        .is_some()
                    {
                        log::warn!("Mixer's event queue is full.");
                        log::warn!(
                            "Increase the mixer event queue to prevent this from happening..."
                        );
                    }
                    // Do not remove from playing_sources, as the event applies somewhen in future.
                    remove_from_playing_sources = false;
                } else {
                    playing_source.playback_message_queue.send_stop()?;
                    // we shortly will receive an exhausted event which removes the source, but nevertheless
                    // remove it now, to force all following attempts to stop this source to fail.
                    remove_from_playing_sources = true;
                }
            }
            None => return Err(Error::MediaFileNotFound),
        }
        if remove_from_playing_sources {
            self.playing_sources.remove(&playback_id);
        }
        Ok(())
    }

    /// Immediately stop all playing and possibly scheduled sources.
    pub fn stop_all_sources(&mut self) -> Result<(), Error> {
        // stop everything that is playing now
        let playing_source_ids = {
            self.playing_sources
                .iter()
                .map(|e| *e.key())
                .collect::<Vec<_>>()
        };
        for source_id in playing_source_ids {
            let _ = self.stop_source(source_id, None);
        }
        // remove all upcoming, scheduled sources in all mixers too (force push stop events!)
        for queue in self.mixer_event_queues.iter() {
            if queue
                .value()
                .force_push(MixerMessage::RemoveAllPendingSources)
                .is_some()
            {
                log::warn!("Mixer's event queue is full.");
                log::warn!("Increase the mixer event queue to prevent this from happening...");
            }
        }
        Ok(())
    }
}

/// details
impl Player {
    fn handle_playback_events(
        playback_sender: Option<Sender<PlaybackStatusEvent>>,
        playing_sources: Arc<DashMap<PlaybackId, PlayingSource>>,
    ) -> Sender<PlaybackStatusEvent> {
        let (playback_send_proxy, playback_recv_proxy) = {
            // use same capacity in proxy as original one
            if let Some(playback_sender) = &playback_sender {
                if let Some(capacity) = playback_sender.capacity() {
                    crossbeam_channel::bounded::<PlaybackStatusEvent>(capacity)
                } else {
                    crossbeam_channel::unbounded::<PlaybackStatusEvent>()
                }
            // use a bounded channel with a default cap for playback tracking, when there's no original channel
            } else {
                const DEFAULT_PLAYBACK_EVENTS_CAPACITY: usize = 1024;
                crossbeam_channel::bounded::<PlaybackStatusEvent>(DEFAULT_PLAYBACK_EVENTS_CAPACITY)
            }
        };

        std::thread::Builder::new()
            .name("audio_player_messages".to_string())
            .spawn(move || loop {
                if let Ok(event) = playback_recv_proxy.recv() {
                    if let PlaybackStatusEvent::Stopped { id, .. } = event {
                        playing_sources.remove(&id);
                    }
                    if let Some(sender) = &playback_sender {
                        // NB: send and not try_send: block until sender queue is free
                        if let Err(err) = sender.send(event) {
                            log::warn!("failed to send file status message: {err}");
                        }
                    }
                } else {
                    log::info!("playback event loop stopped");
                    break;
                }
            })
            .expect("failed to spawn audio message thread");

        playback_send_proxy
    }

    fn handle_drop_collects(mut collector: Collector, running: Arc<AtomicBool>) {
        std::thread::Builder::new()
            .name("audio_player_drops".to_string())
            .spawn(move || {
                while running.load(atomic::Ordering::Relaxed) {
                    collector.collect();
                    thread::sleep(time::Duration::from_millis(100));
                }
                log::info!("audio collector loop stopped");
                collector.collect();
                if collector.try_cleanup().is_err() {
                    log::warn!("Failed to cleanup collector");
                }
            })
            .expect("failed to spawn audio message thread");
    }

    fn effect_mixer_event_queue(
        &self,
        effect_id: EffectId,
    ) -> Result<Arc<ArrayQueue<MixerMessage>>, Error> {
        let (mixer_id, _) = *self
            .mixer_effects
            .get(&effect_id)
            .ok_or(Error::EffectNotFoundError(effect_id))?
            .value();
        let event_queue = self
            .mixer_event_queues
            .get(&mixer_id)
            .ok_or(Error::MixerNotFoundError(mixer_id))?
            .value()
            .clone();
        Ok(event_queue)
    }
}

impl Drop for Player {
    fn drop(&mut self) {
        // stop collector thread
        self.collector_running
            .store(false, atomic::Ordering::Relaxed);
        // stop playback thread and release mixer source
        self.output_device.close();
    }
}
